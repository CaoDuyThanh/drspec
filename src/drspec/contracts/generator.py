"""Verification script generator for DrSpec contracts.

This module generates executable Python verification scripts from contracts.
These scripts can verify that a function's behavior matches its contract.
"""

from __future__ import annotations

import hashlib
import re
from typing import Optional

from drspec.contracts.schema import Contract, Invariant


def generate_verification_script(contract: Contract, function_id: str) -> str:
    """Generate a verification script from a contract.

    The generated script contains a verify() function that checks all
    invariants against provided input/output data.

    Args:
        contract: The contract to generate a script for.
        function_id: The function ID for documentation purposes.

    Returns:
        Python source code as a string.
    """
    lines: list[str] = []

    # Module docstring
    lines.append('"""')
    lines.append(f"Verification script for: {function_id}")
    lines.append("Generated by DrSpec")
    lines.append("")
    lines.append(f"Contract Intent: {contract.intent_summary}")
    lines.append('"""')
    lines.append("")
    lines.append("from __future__ import annotations")
    lines.append("")
    lines.append("from typing import Any, Tuple")
    lines.append("")
    lines.append("")

    # Generate individual check functions for each invariant
    for i, invariant in enumerate(contract.invariants, 1):
        lines.extend(_generate_invariant_check(i, invariant))
        lines.append("")

    # Generate main verify function
    lines.extend(_generate_verify_function(contract.invariants))

    return "\n".join(lines)


def _generate_invariant_check(index: int, invariant: Invariant) -> list[str]:
    """Generate a check function for a single invariant.

    Args:
        index: 1-based index of the invariant.
        invariant: The invariant to generate a check for.

    Returns:
        Lines of Python code.
    """
    lines: list[str] = []

    # Function definition with docstring
    func_name = f"_check_invariant_{index}"
    lines.append(f"def {func_name}(input_data: dict[str, Any], output_data: Any) -> bool:")
    lines.append(f'    """Check: {invariant.name}')
    lines.append("")
    lines.append(f"    Logic: {invariant.logic}")
    lines.append(f"    Criticality: {invariant.criticality.value}")
    lines.append('    """')

    # Try to translate the invariant logic to Python
    check_code = _translate_invariant_logic(invariant.logic, invariant.name)

    if check_code:
        lines.append("    try:")
        lines.append(f"        return {check_code}")
        lines.append("    except Exception:")
        lines.append("        # If check fails due to missing data or type error, return False")
        lines.append("        return False")
    else:
        # Untranslatable invariant
        lines.append(f'    # NOTE: Cannot automatically verify "{invariant.logic}"')
        lines.append("    # Manual implementation required")
        lines.append("    # Returning True (optimistic) - replace with actual check")
        lines.append("    return True")

    return lines


def _generate_verify_function(invariants: list[Invariant]) -> list[str]:
    """Generate the main verify() function.

    Args:
        invariants: List of invariants to check.

    Returns:
        Lines of Python code.
    """
    lines: list[str] = []

    lines.append("def verify(input_data: dict[str, Any], output_data: Any) -> Tuple[bool, str]:")
    lines.append('    """')
    lines.append("    Verify the function's behavior against its contract.")
    lines.append("")
    lines.append("    Args:")
    lines.append("        input_data: Dictionary of input parameters")
    lines.append("        output_data: The function's return value")
    lines.append("")
    lines.append("    Returns:")
    lines.append("        Tuple of (passed: bool, message: str)")
    lines.append('    """')
    lines.append("    try:")

    # Check each invariant
    for i, invariant in enumerate(invariants, 1):
        lines.append(f"        # Invariant {i}: {invariant.name}")
        lines.append(f"        if not _check_invariant_{i}(input_data, output_data):")
        lines.append(f'            return (False, "Invariant \'{invariant.name}\' violated: {_escape_string(invariant.logic)}")')
        lines.append("")

    lines.append(f'        return (True, "All {len(invariants)} invariant(s) passed")')
    lines.append("")
    lines.append("    except Exception as e:")
    lines.append('        return (False, f"Verification error: {str(e)}")')
    lines.append("")

    return lines


def _escape_string(s: str) -> str:
    """Escape a string for use in Python code.

    Args:
        s: String to escape.

    Returns:
        Escaped string safe for inclusion in Python code.
    """
    return s.replace("\\", "\\\\").replace('"', '\\"').replace("\n", "\\n")


def _translate_invariant_logic(logic: str, name: str) -> Optional[str]:
    """Attempt to translate natural language invariant to Python code.

    This is a best-effort translation that handles common patterns.
    Returns None if the invariant cannot be automatically translated.

    Args:
        logic: Natural language description of the invariant.
        name: Name of the invariant (may provide hints).

    Returns:
        Python expression string, or None if untranslatable.
    """
    logic_lower = logic.lower().strip()

    # Pattern: output is not empty / non-empty output
    if any(p in logic_lower for p in ["not empty", "non-empty", "non empty", "nonempty"]):
        if "output" in logic_lower:
            return "len(output_data) > 0 if hasattr(output_data, '__len__') else output_data is not None"
        if "input" in logic_lower:
            return "all(len(v) > 0 if hasattr(v, '__len__') else v is not None for v in input_data.values())"

    # Pattern: output is not None / returns something
    if any(p in logic_lower for p in ["not none", "is not none", "returns something"]):
        return "output_data is not None"

    # Pattern: positive values / greater than zero
    if any(p in logic_lower for p in ["positive", "greater than zero", "> 0", ">0"]):
        if "all" in logic_lower or "every" in logic_lower:
            if "output" in logic_lower:
                return "all(x > 0 for x in output_data) if hasattr(output_data, '__iter__') else output_data > 0"
        if "output" in logic_lower or "result" in logic_lower:
            return "output_data > 0"

    # Pattern: non-negative values
    if any(p in logic_lower for p in ["non-negative", "non negative", "nonnegative", ">= 0", ">=0"]):
        if "all" in logic_lower or "every" in logic_lower:
            if "output" in logic_lower:
                return "all(x >= 0 for x in output_data) if hasattr(output_data, '__iter__') else output_data >= 0"
        if "output" in logic_lower or "result" in logic_lower:
            return "output_data >= 0"

    # Pattern: no duplicates
    if any(p in logic_lower for p in ["no duplicate", "no duplicates", "unique", "distinct"]):
        if "id" in logic_lower or "ids" in logic_lower:
            return "len(output_data.get('ids', [])) == len(set(output_data.get('ids', []))) if isinstance(output_data, dict) else True"
        if "output" in logic_lower:
            return "len(output_data) == len(set(output_data)) if hasattr(output_data, '__iter__') and not isinstance(output_data, (str, dict)) else True"

    # Pattern: sum/total preserved
    if any(p in logic_lower for p in ["sum preserved", "sum is preserved", "total preserved", "total is preserved"]):
        return "sum(input_data.get('values', [])) == sum(output_data) if hasattr(output_data, '__iter__') else True"

    # Pattern: length/count preserved
    if any(p in logic_lower for p in ["length preserved", "count preserved", "same length", "same size"]):
        return "len(input_data.get('items', input_data.get('values', []))) == len(output_data) if hasattr(output_data, '__len__') else True"

    # Pattern: contains/includes
    if "contains" in logic_lower or "includes" in logic_lower:
        if "@" in logic_lower and "email" in logic_lower:
            return "'@' in str(output_data)"

    # Pattern: starts with / ends with
    if "starts with" in logic_lower:
        # Try to extract what it should start with
        match = re.search(r"starts with ['\"]?([^'\"]+)['\"]?", logic_lower)
        if match:
            prefix = match.group(1).strip()
            return f"str(output_data).startswith('{prefix}')"

    if "ends with" in logic_lower:
        match = re.search(r"ends with ['\"]?([^'\"]+)['\"]?", logic_lower)
        if match:
            suffix = match.group(1).strip()
            return f"str(output_data).endswith('{suffix}')"

    # Pattern: type checks
    if "is a list" in logic_lower or "returns a list" in logic_lower:
        return "isinstance(output_data, list)"
    if "is a dict" in logic_lower or "returns a dict" in logic_lower or "is a dictionary" in logic_lower:
        return "isinstance(output_data, dict)"
    if "is a string" in logic_lower or "returns a string" in logic_lower:
        return "isinstance(output_data, str)"
    if "is an int" in logic_lower or "returns an int" in logic_lower or "is an integer" in logic_lower:
        return "isinstance(output_data, int)"
    if "is a bool" in logic_lower or "returns a bool" in logic_lower or "is a boolean" in logic_lower:
        return "isinstance(output_data, bool)"

    # Pattern: equals input
    if "equals input" in logic_lower or "same as input" in logic_lower:
        return "output_data == input_data"

    # Pattern: double/triple/multiply
    if "double" in logic_lower or "doubled" in logic_lower or "twice" in logic_lower:
        # Look for what input parameter
        for key in ["x", "n", "value", "num", "input"]:
            if key in logic_lower:
                return f"output_data == input_data.get('{key}', 0) * 2"
        return "True  # Cannot determine which input to double"

    # Pattern: less than or equal, greater than or equal
    if "less than or equal" in logic_lower or "<=" in logic_lower:
        if "input" in logic_lower and "output" in logic_lower:
            return "output_data <= sum(input_data.values()) if isinstance(output_data, (int, float)) else True"
    if "greater than or equal" in logic_lower or ">=" in logic_lower:
        if "input" in logic_lower and "output" in logic_lower:
            return "output_data >= sum(input_data.values()) if isinstance(output_data, (int, float)) else True"

    # Pattern: within range / between
    if "between" in logic_lower or "within" in logic_lower or "range" in logic_lower:
        match = re.search(r"between\s+(\d+)\s+and\s+(\d+)", logic_lower)
        if match:
            low, high = match.groups()
            return f"{low} <= output_data <= {high}"

    # Unable to translate
    return None


def compute_script_hash(script: str) -> str:
    """Compute a hash for the verification script.

    Used to detect if a script has changed.

    Args:
        script: The script source code.

    Returns:
        SHA-256 hash of the script.
    """
    return hashlib.sha256(script.encode()).hexdigest()
